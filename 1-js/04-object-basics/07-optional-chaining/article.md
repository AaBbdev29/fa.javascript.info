# Optional chaining '?.' یا زنجیره ای اختیاری
[recent browser="new"]

###### زنجیره ای اختیاری روشی بدون خطا برای دستیابی به ویژگی های(properties) داخلی شی است حتی در زمانی که ویژگی میانی وجود نداشته باشد



## مشکل

اگر به تازگی شروع به خواندن آموزش و یادگیری جاوا اسکریپت کرده اید ، شاید این مشکل هنوز شما را لمس نکرده اید ، اما این یک مشکل کاملاً رایج است.

برای مثال٬ تعدادی از کاربران ما آدرس دارند ولی تعدادی کمی از آن ها آدرس را ارائه نکرده‌اند. بنابراین ما به طور مطمئن نمیتوانیم این `user.address.street` مقدار را بخوانیم :

```js run
let user = {}; // the user happens to be without address

alert(user.address.street); // Error!
```



یا در توسعه وب٬ ما میخواهیم اطلاعاتی در مورد اِلمان در صفحه را بگیریم٬ ولی شاید وجود نداشته باشد :

```js run
// Error if the result of querySelector(...) is null
let html = document.querySelector('.my-element').innerHTML;
```



قبل از اینکه  `?.`  در زبان وجود داشته باشد از عمگر `&&` برای کار در این مورد استفاده میشد. برای مثال :

```js run
let user = {}; // user has no address

alert( user && user.address && user.address.street ); // undefined (no error)
```

AND کردن کل مسیر رسیدن به ویژگی ، وجود همه اجزا را تضمین می کند ، اما نوشتن آن دست و پا گیر است.





## زنجیره ای اختیاری

زنجیره ای اختیاری `?.` ارزیابی را متوقف میکند  اگر مقدار قبل از قسمت  `?.`  برابر با `undefined` یا `null` باشد و مقدار `undefined` را برمیگرداند.

**در ادامه این مقاله ، به اختصار خواهیم گفت چیزی وجود خواهد داشت اگر که `undefined` و `null`  نباشد.**



این یک مسیر امن برای دستیابی  `user.address.street` است :

```js run
let user = {}; // user has no address

alert( user?.address?.street ); // undefined (no error)
```



خواندن آدرس با  `user?.address` کار خواهد کرد حتی زمانی هم که  شی `user` وجود ندارد :

```js run
let user = null;

alert( user?.address ); // undefined
alert( user?.address.street ); // undefined
```

لطفا توجه داشته باشید : سینتکس `?.` مقدارهای قبلی را اختیاری میکند نه مقدارهای جلوی آن را.

در مثال بالا `user?.`  به `user` مقدار `null/undefined` خواهد داد.



از طرف دیگر ، اگر ‍‍`user` وجود داشته باشد ، پس باید ویژگی `user.address` داشته باشد ، در غیر این صورت `user؟.address.street `در نقطه دوم خطا می دهد.

```warn header="از زنجیر اختیاری بیش از حد استفاده تکنید"

ما باید از `?.` فقط زمانی استفاده کنیم که عدم وجود چیزی اشکالی ندارد

به عنوان مثال ، اگر مطابق منطق برنامه نویسی ما ، شی `user` باید وجود داشته باشد ولی `address` اختیاری است در آن شرایط استفاده از `user.address?.street` راه حل بهتری است ،

بنابراین ، اگر تصادفاً به دلیل هر اشتباهی یوزر اندیفایند باشد ، ما درمورد آن اطلاعاتی خواهیم یافت و آن را برطرف خواهیم کرد. در غیر این صورت ، خطاهای کد را می توان در مواردی که مناسب نیست ساکت کرد و اشکال زدایی آنها دشوارتر می شود.
```



````warn header="متغیر قبل از ؟. باید تعریف شده باشد" اگر متغیر user به هیچ وجه وجود نداشته باشد `user?.anything` خطا خواهد داد



```js run
// ReferenceError: user is not defined
user?.address;
```
باید `let/const/var user `  وجود داشته باشد. زنجیره ای اختیاری فقط برای متغیرهای تعریف شده کار می کند.

````

## اتصال کوتاه
همانطور که قبلا گفته شد عبارت `?.` فوراً ارزیابی را متوقف میکند(اتصال کوتاه) اگر عبارت سمت چپ آن وجود نداشته باشد.
بنابراین ، اگر صدا زدن تابعی یا عوارض جانبی دیگری وجود داشته باشد ، اتفاق نمی‌افتد :

​```js run
let user = null;
let x = 0;

user?.sayHi(x++); // nothing happens

alert(x); // 0, value not incremented
```



## ?.(), ?.[] : و موارد دیگر

زنجیره اختیاری `?.`  یک عمگر نیست بلکه یک ساختار سینتکسی خاص است که با توابع و براکت ها نیز کار می کند

برای مثال `?.()` برای صدا زدن تابعی که ممکن است وجود نداشته باشد هم کاربرد دارد

در کد زیر٬ برخی از کاربران ما متد `admin` را دارند و برخی خیر :

```js run
let user1 = {
  admin() {
    alert("I am admin");
  }
}

let user2 = {};

*!*
user1.admin?.(); // I am admin
user2.admin?.();
*/!*
```

در اینجا در هر دو خط ما ابتدا از `.` برای گرفتن ویژگی ‍`admin` استفاده میکنیم به خاطر اینکه شی ‍`user` حتما وجود دارد پس برای خواندن از آن مطمئن هستیم.

سپس `?.()` عبارت سمت چپ را بررسی میکند: اگر تابع ‍`admin` وجود داشته باشد آنرا اجرا میکند(برای ‍`user1`)  در غیر اینصورت(برای `user2`) محاسبات بدون خطا به متوقف میشود.

سینتکس برای حالت `?.[]` نیز کار میکند٬ اگر ما میخواهیم از براکت به جای نقطه برای دستیابی به ویژگی‌ها استفاده کنیم مشابه موارد قبلی ، اجازه می دهد تا با خیال راحت یک ویژگی را از یک شی که ممکن است وجود نداشته باشد،  را بخوانیم.

```js run
let user1 = {
  firstName: "John"
};

let user2 = null; // Imagine, we couldn't authorize the user

let key = "firstName";

alert( user1?.[key] ); // John
alert( user2?.[key] ); // undefined

alert( user1?.[key]?.something?.not?.existing); // undefined
```

همچنان ما میتوانیم از `?.` در  `delete` هم استفاده کنیم

```js run
delete user?.name; // delete user.name if user exists
```

 ```warn header="میتوانیم از ؟. برای پاک کردن و خواندن مطمئن استفاده کنیم ولی نوشتن نه"
زنجیره اختیاری `?.` هیچ کاربردی برای سمت چپ مساوی ندارد


​```js run
// the idea of the code below is to write user.name, if user exists

user?.name = "John"; // Error, doesn't work
// because it evaluates to undefined = "John"
 ```



## خلاصه

سینتکس `?.`  سه شکل دارد:



1. `obj?.prop` -  مقدار ‍‍`obj.prop` را برمیگرداند اگر `obj` وجود داشته باشد در غیر اینصورت مقدار `undefined`  را برمیگرداند
2. `[obj?.[prop` -  مقدار ‍‍`[obj.[prop` را برمیگرداند اگر `obj` وجود داشته باشد در غیر اینصورت مقدار `undefined`  را برمیگرداند
3. `()obj.method()`  -   ‍‍``obj?.method`` را صدا میزند اگر `obj` وجود داشته باشد در غیر اینصورت مقدار `undefined`  را برمیگرداند



همانطور که می بینیم ، همه آنها ساده و آسان برای استفاده هستند. `?.`  سمت چپ را از نظر `null/undefined` بررسی می کند و اجازه می دهد تا ارزیابی ادامه یابد اگر برابر با  `null/undefined`  نباشد.

زنجیر `?.` امکان دسترسی به خواص تودرتو را فراهم میکند.

با این حال هنوز ما باید `?.` را با دقت اعمال کنیم ، فقط درصورتی شکالی ندارد که سمت چپ ممکن است وجود نداشته باشد.

با این حال خطاهای برنامه نویسی را مخفی نمیکند اگر آنها اتفاق بیافتند.