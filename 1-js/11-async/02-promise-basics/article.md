# وعده (promise)

تصور کنید که یک خواننده برتر هستید و طرفداران شب و روز درخواست آهنگ بعدی شما را دارند.

برای اینکه کمی راحت بشوید، قول می‌دهید پس از انتشار آن را برای آن‌ها ارسال کنید. شما یک لیست به طرفداران خود می‌دهید. آن‌ها می‌توانند آدرس ایمیل خود را پر کنند، به طوری که وقتی آهنگ در دسترس قرار گرفت، همه مشترکین فورا آن را دریافت کنند. و حتی اگر مشکلی پیش بیاید، فرض کنید آتش سوزی در استودیو، به طوری که نتوانید آهنگ را منتشر کنید، باز هم به آن‌ها اطلاع داده خواهد شد.

همه خوشحال هستند: شما، چون مردم دیگر مزاحم شما نمی‌شوند، و طرفداران، چون آهنگ را از دست نمی‌دهند.

این یک تشبیه واقعی برای چیزهایی است که اغلب در برنامه‌نویسی داریم:

1. یک "کد تولید‌کننده" که کاری انجام می‌دهد و زمانی می‌برد. به عنوان مثال، کدهایی که داده‌ها را از طریق شبکه بارگیری می‌کند. این یک "خواننده" است.
2. یک "کد مصرف‌کننده" که نتیجه‌ی "کد تولیدکننده" را پس از آماده شدن می خواهد. بسیاری از توابع ممکن است به آن نتیجه نیاز داشته باشند. اینها "طرفداران" هستند.
3. یک *وعده* (*promise*) یک شیء خاص جاوااسکریپت است که "کد تولید‌کننده" و "کد مصرف‌کننده" را به یکدیگر پیوند می‌دهد. از نظر تشبیه ما: این فهرست اشتراک است. "کد تولید‌کننده" هر زمانی را که برای تولید نتیجه وعده داده شده نیاز دارد طول می‌کشد، و "وعده" (promise) آن نتیجه را پس از آماده شدن برای همه کدهای مشترک شده در دسترس قرار می‌دهد.

این تشبیه خیلی دقیق نیست، زیرا وعده‌های (promises) جاوا‌اسکریپت پیچیده‌تر از یک لیست اشتراک ساده است: آن‌ها دارای ویژگی‌ها و محدودیت‌های اضافی هستند. اما برای شروع خوب است.

سینتکس سازنده برای یک شیء وعده(promise) به صورت زیر است:

```js
let promise = new Promise(function(resolve, reject) {
  // اجراکننده (کد تولیدکننده , "خواننده")
});
```

تابعی که به `new Promise` ارسال می‌شود *اجرا‌کننده* نامیده می‌شود. هنگامی که `new Promise` ایجاد می‌شود، اجرا‌کننده به طور خودکار اجرا می‌شود. این شامل کد تولید‌کننده است که در نهایت باید نتیجه را ایجاد کند. از نظر تشبیه بالا: اجراکننده "خواننده" است.

آرگومان‌های آن `resolve` و `reject`  فراخوان‌هایی هستند که توسط خود جاوا‌اسکریپت ارائه شده است. کد ما فقط در داخل اجرا‌کننده است.

وقتی اجرا‌کننده به نتیجه رسید، چه زود باشد چه دیر، مهم نیست، باید یکی از این callback ها را فراخوانی کند:

- `resolve(value)` — `value` اگر کار با موفقیت به پایان رسید، با نتیجه‌ی.
- `reject(error)` — همان شیء خطا است `error` ، اگر خطایی رخ داده باشد  

بنابراین به طور خلاصه: اجراکننده به طور خودکار اجرا می‌شود و تلاش می‌کند تا یک کار را انجام دهد. هنگامی که کار با تلاش به پایان رسید، در صورت موفقیت‌آمیز بودن، `resolve` یا در صورت وجود هر خطایی `reject` را فراخوانی می‌کند.

شیء `promise` که توسط سازنده `new Promise` برگردانده شده است دارای این ویژگی‌های داخلی است:

- `state` — .تغییر می‌کند `"rejected"` فراخوانی می‌شود به `reject` یا زمانی که `"fulfilled"` به `resolve` سپس با فراخوانی، `"pending"` در ابتدا
- `result` — .تغییر می‌کند `error` فراخوانی می شود به `reject(error)`  یا زمانی که `value` به `resolve(value)` سپس با فراخوانی ،`undefined` در ابتدا

بنابراین اجرا‌کننده در نهایت `promise` را به یکی از این حالات منتقل می‌کند:

![](promise-resolve-reject.svg)

بعداً خواهیم دید که چگونه "طرفداران" می‌توانند در این تغییرات مشترک شوند.

در اینجا یک نمونه از سازنده وعده (promise) و یک تابع اجرا‌کننده ساده با "کد تولید‌کننده" است که زمانی می‌برد (از طریق `setTimeout`):

```js run
let promise = new Promise(function(resolve, reject) {
  //  ساخته می‌شود به طور خودکار اجرا می‌شود (promise)این تابع زمانی که وعده

  // انجام شد "done" پس از 1 ثانیه سیگنال می‌دهد که کار با نتیجه 
  setTimeout(() => *!*resolve("انجام شده")*/!*, 1000);
});
```

با اجرای کد بالا می توانیم دو چیز را ببینیم:

۱. اجرا‌کننده به صورت خودکار و بلافاصله فراخوانی می‌شود (توسط `new Promise`).<br /> 
۲. اجرا‌کننده دو آرگومان دریافت می‌کند: `resolve` و `reject`. این توابع توسط موتور جاوااسکریپت از پیش تعریف شده‌اند, بنابراین ما نیازی به ایجاد آن‌ها نداریم. وقتی آماده شدیم فقط باید یکی از آن‌ها را فراخوانی کنیم.

    :را تغییر می‌دهد `promise` را برای ایجاد نتیجه فراخوانی می‌کند. این وضعیت شیء `resolve("done")` پس از یک ثانیه "پردازش"، اجرا‌کننده

    ![](promise-resolve-1.svg)

این نمونه‌ای از تکمیل موفقیت آمیز کار بود، یک "fulfilled promise".

و حال نمونه‌ای از ردشدن(rejecting) وعده‌ی(promise) اجرا‌کننده با یک خطا:

```js
let promise = new Promise(function(resolve, reject) {
  // بعد از 1 ثانیه سیگنال می‌دهد که کار با یک خطا تمام شده است
  setTimeout(() => *!*reject(new Error("Whoops!"))*/!*, 1000);
});
```

فراخوانیِ `(...)reject` شیء وعده(promise) را به وضعیت `"rejected"` می‌برد:

![](promise-reject-1.svg)

به طور خلاصه، اجرا‌کننده باید یک کار را انجام دهد (معمولاً کاری که زمان می‌برد) و سپس `resolve` یا `reject` را برای تغییر وضعیت شیء وعده‌ی(promise) مربوطه فراخوانی کند.

به وعده‌ای که یا حل‌و‌فصل(resolved) می‌شود یا رد(rejected) می‌شود، "تسویه‌شده" ("settled") می‌گویند، برخلاف وعده‌ای(promise) که در ابتدا "درحال انتظار" ("pending") است.

````smart header="تنها یک نتیجه یا یک خطا می تواند وجود داشته باشد"
.را فراخوانی کند. هر تغییر وضعیتی نهایی است `reject` یا یک `resolve` اجرا‌کننده باید فقط یک

:نادیده گرفته می‌شوند `reject` و `resolve` همه فراخوانی‌های دیگر از

```js
let promise = new Promise(function(resolve, reject) {
*!*
  resolve("انجام شده");
*/!*

  reject(new Error("…")); // نادیده گرفته شد
  setTimeout(() => resolve("…")); // نادیده گرفته شد
});
```

ایده این است که کار انجام شده توسط اجرا‌کننده ممکن است تنها یک نتیجه یا یک خطا داشته باشد.

.تنها یک آرگومان (یا هیچی) را انتظار دارد و آرگومان‌های اضافی را نادیده می‌گیرد `resolve`/`reject` ،همچنین
````

```smart header="کنید (reject)رد `Error` با اشیاء"</br>
<span dir="rtl">در صورتی که مشکلی پیش بیاید، اجرا‌کننده باید `reject` را فراخوانی کند. این کار می‌تواند با هر نوع آرگومانی انجام شود (دقیقاً مانند `resolve`). اما توصیه می‌شود از اشیاء `Error` (یا اشیایی که از `Error` به ارث می‌برند) استفاده کنید. دلیل آن به زودی مشخص خواهد شد.<span>
```

````smart header="را فراخوانی می‌کند `Resolve`/`Reject` بلافاصله"
:را فراخوانی کنیم، مانند این `reject` یا `resolve` را فراخوانی می‌کند، اما مجبور نیست. همچنین می‌توانیم بلافاصله `resolve`/`reject` در عمل، یک اجرا‌کننده معمولاً کاری را به صورت ناهمزمان انجام می‌دهد و پس از مدتی

```js
let promise = new Promise(function(resolve, reject) {
  // وقت خود را برای انجام کار صرف نمی کنیم
  resolve(123); // بلافاصله نتیجه را بدهید: 123
});
```

به عنوان مثال، این ممکن است زمانی اتفاق بیفتد که ما شروع به انجام یک کار می‌کنیم، اما بعد می‌بینیم که همه چیز قبلاً تکمیل شده و در حافظه پنهان(cache) ذخیره شده است.

خوبه. ما بلافاصله یک وعده(promise) حل‌شده(resolved) داریم.
````

```smart header="داخلی هستند `result` و `state`"
.استفاده کنیم. در زیر توضیح داده شده‌اند `.then`/`.catch`/`.finally` داخلی هستند. ما نمی‌توانیم مستقیماً به آن‌ها دسترسی داشته باشیم. برای این کار می‌توانیم از متدهای Promise شیء `result` و `state` ویژگی های
`````

## مصرف‌کنندگان: then, catch, finally

یک شیء Promise به عنوان یک پیوند بین اجراکننده ("کد تولید‌کننده" یا "خواننده") و توابع مصرف‌کننده ("طرفداران") عمل می‌کند که نتیجه یا خطا را دریافت می‌کند. توابع مصرف‌کننده را می‌توان با استفاده از متدهای `then`، `.catch.` و `finally.` ثبت (مشترک) کرد.

### متدِ then

مهم ترین و اساسی ترین آن `then.` است.

سینتکس عبارت است از:

```js
promise.then(
  function(result) { *!*/* یک نتیجه موفق را مدیریت کنید */*/!* },
  function(error) { *!*/* یک خطا را مدیریت کنید */*/!* }
);
```

اولین آرگومان `then.` تابعی است که با حل شدن(resolved) وعده(promise) اجرا می‌شود و نتیجه را دریافت می‌کند.

آرگومان دوم `then.` تابعی است که با رد شدن(rejected) وعده(promise) اجرا می‌شود و خطا را دریافت می‌کند.

به عنوان مثال، در اینجا یک واکنش به یک وعده‌ی(promise) با موفقیت حل شده(resolved) داریم:

```js run
let promise = new Promise(function(resolve, reject) {
  setTimeout(() => resolve("انجام شده!"), 1000);
});

// اجرا می کند resolve را .then اولین تابع در
promise.then(
*!*
  result => alert(result), // بعد از 1 ثانیه  "انجام شده!" را نشان می‌دهد 
*/!*
  error => alert(error) //  اجرا نمی‌شود
);
```

اولین تابع اجرا شد.

و در صورت ردشدن دومی:

```js run
let promise = new Promise(function(resolve, reject) {
  setTimeout(() => reject(new Error("Whoops!")), 1000);
});

// اجرا می کند .then تابع دوم را در reject 
promise.then(
  result => alert(result), // اجرا نمی‌شود
*!*
  error => alert(error) // نشان می‌دهد "Error: Whoops!" بعد از 1 ثانیه
*/!*
);
```

اگر فقط به تکمیل موفقیت‌آمیز علاقه داریم، می‌توانیم تنها یک آرگومان تابع را برای `then.` ارائه کنیم:

```js run
let promise = new Promise(resolve => {
  setTimeout(() => resolve("انجام شده!"), 1000);
});

*!*
promise.then(alert); // نشان می‌دهد "done!" بعد از 1 ثانیه
*/!*
```

### متدِ catch

اگر فقط به خطاها علاقه‌مند هستیم، می‌توانیم از `null` به عنوان اولین آرگومان استفاده کنیم: `then(null، errorHandlingFunction).`. یا می‌توانیم از `catch(errorHandlingFunction).` استفاده کنیم که دقیقاً مشابه است:


```js run
let promise = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error("Whoops!")), 1000);
});

*!*
// .catch(f) is the same as promise.then(null, f)
promise.catch(alert); // .را بعد از 1 ثانیه نشان می‌دهد "Error: Whoops!" خطای
*/!*
```

فراخوانی `catch(f).` یک تشابه کامل از `then(null, f).` است. این فقط یک کوتاه نویسی است.

### متدِ finally

درست مانند یک بند `finally` در یک `catch {...} try {...}` معمولی، در وعده‌ها(promises) نیز `finally` وجود دارد.

فراخوانی `finally(f).` شبیه به `then(f, f).` است به این معنا که `f` همیشه زمانی که وعده(promise) تسویه(settled) می‌شود اجرا می‌شود: خواه حل‌وفصل(resolve) یا رد(reject) شود.

متدِ `finally` یک کنترل‌کننده خوب برای انجام پاکسازی است، به عنوان مثال. نشانگرهای بارگیری(loading indicators) خود را متوقف می‌کنیم، زیرا بدون توجه به نتیجه، دیگر به آن‌ها نیازی نیست.

مثل این:

```js
new Promise((resolve, reject) => {
  /* را فراخوانی کنید resolve/reject کاری را انجام دهید که زمان می‌برد و سپس */
})
*!*
  // زمانی اجرا می‌شود که وعده تسویه شود، مهم نیست موفقیت‌آمیز باشد یا نه
  .finally(() => توقف نشانه‌گر بارگیری)
  // بنابراین نشانگر بارگیری همیشه قبل از پردازش نتیجه/خطا متوقف می‌شود
*/!*
  .then(result => نمایش نتیجه, err => نمایش خطا)
```

با این حال، `finally(f)` دقیقاً نام مستعار `then(f,f)` نیست. چند تفاوت ظریف وجود دارد:

۱. یک کنترل‌کننده `finally` هیچ آرگومانی ندارد. در `finally` ما نمی‌دانیم که آیا وعده(promise) موفق است یا نه. همه چیز درست است، زیرا وظیفه ما معمولاً انجام مراحل نهایی‌سازی "عمومی" است.  
۲. یک کنترل‌کننده `finally` نتایج و خطاها را به کنترل‌کننده بعدی منتقل می‌کند.

    :منتقل می‌شود `then` به `finally` به عنوان مثال، در اینجا نتیجه از
    ```js run
    new Promise((resolve, reject) => {
      setTimeout(() => resolve("result"), 2000)
    })
      .finally(() => alert("Promise آماده است"))
      .then(result => alert(result)); // <-- نتیجه را اجرا می‌کند .then
    ```

    :پاس داده می‌شود `catch` به `finally` و در اینجا یک خطایی در وعده وجود دارد که از

    ```js run
    new Promise((resolve, reject) => {
      throw new Error("خطا");
    })
      .finally(() => alert("Promise آماده است"))
      .catch(err => alert(err));  // <-- شیء خطا را اجرا می‌کند .catch 
    ```

این بسیار راحت است، زیرا `finally` به معنای پردازش یک نتیجه وعده(promise) نیست. بنابراین از آن عبور می‌کند.

در فصل بعدی بیشتر در مورد زنجیره وعده(promise) و انتقال نتیجه بین کنترل‌کننده‌ها صحبت خواهیم کرد.


````smart header="ما می توانیم اجراکننده‌ها را به وعده‌های تسویه‌شده متصل کنیم"
اگر وعده‌ای در حال تعلیق است، کنترل‌کننده‌ها `then/catch/finally.` منتظر آن هستند. در غیر این صورت، اگر وعده‌ای قبلاً تسویه شده باشد، آنها فقط اجرا می کنند:

```js run
// وعده بلافاصله پس از ایجاد حل‌وفصل می‌شود
let promise = new Promise(resolve => resolve("انجام شده!"));

promise.then(alert); //  (همین الآن نشان می‌دهد) انجام شده!
```

توجه داشته باشید که این باعث می‌شود وعده‌ها قدرتمندتر از سناریوی واقعی "فهرست اشتراک" باشد. اگر خواننده قبلا آهنگ خود را منتشر کرده باشد و سپس شخصی در لیست اشتراک ثبت نام کند، احتمالاً آن آهنگ را دریافت نخواهد کرد. اشتراک در دنیای واقعی باید قبل از رویداد انجام شود.

وعده‌ها انعطاف‌پذیرتر هستند. ما می توانیم هر زمان که بخواهیم کنترل‌کننده‌ها را اضافه کنیم: اگر نتیجه از قبل وجود داشته باشد، آنها فقط اجرا می‌شوند.
````

در مرحله بعد، بیایید نمونه‌های عملی بیشتری را ببینیم که چگونه وعده‌ها می‌توانند به ما در نوشتن کد ناهمزمان کمک کنند.

## مثال: loadScript [#loadscript]

ما تابع `loadScript` را برای بارگیری یک اسکریپت از فصل قبل داریم.

در اینجا یک نوع مبتنی بر کال‌بک(callback) است، فقط برای یادآوری آن:

```js
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;

  script.onload = () => callback(null, script);
  script.onerror = () => callback(new Error(`خطای بارگیری اسکریپت برای ${src}`));

  document.head.append(script);
}
```

بیایید آن را با استفاده از Promises بازنویسی کنیم.

تابع جدید `loadScript` نیازی به کال‌بک نخواهد داشت. درعوض، یک شی Promise ایجاد و برمی‌گرداند که پس از اتمام بارگیری حل‌وفصل می‌شود. کد بیرونی می‌تواند با استفاده از `then.`، کنترل‌کننده‌ها (توابع اشتراک) را به آن اضافه کند:

```js run
function loadScript(src) {
  return new Promise(function(resolve, reject) {
    let script = document.createElement('script');
    script.src = src;

    script.onload = () => resolve(script);
    script.onerror = () => reject(new Error(`خطای بارگیری اسکریپت برای ${src}`));

    document.head.append(script);
  });
}
```

Usage:

```js run
let promise = loadScript("https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js");

promise.then(
  script => alert(`${script.src} بارگذاری شده است!`),
  error => alert(`Error: ${error.message}`)
);

promise.then(script => alert('کنترل‌کننده دیگر...'));
```

ما می‌توانیم بلافاصله چند مزیت را نسبت به الگوی مبتنی بر کال‌بک(callback) مشاهده کنیم:


| Promises | Callbacks |
|----------|-----------|
| وعده‌ها به ما این امکان را می‌دهند که کارها را به ترتیب طبیعی انجام دهیم. ابتدا `(loadScript(script` را اجرا می‌کنیم و `.then` می‌نویسیم که با نتیجه چه کنیم. | هنگام فراخوانی `loadScript(script, callback)` باید یک تابع `callback` در اختیار داشته باشیم. به عبارت دیگر، *قبل* از فراخوانی `loadScript` باید بدانیم که با نتیجه چه کنیم. |
| می‌توانیم `.then` را در یک Promise هر چند بار که بخواهیم فراخوانی کنیم. هر بار، یک `طرفدار` جدید، یک تابع اشتراک جدید، به "لیست اشتراک" اضافه می‌کنیم. اطلاعات بیشتر در مورد این در فصل بعدی: [](info:promise-chaining). | فقط یک کال‌بک می‌تواند وجود داشته باشد. |

بنابراین وعده‌ها جریان کد و انعطاف‌پذیری بهتری به ما می‌دهند. اما موارد بیشتری وجود دارد. آن را در فصل‌های بعدی خواهیم دید.
